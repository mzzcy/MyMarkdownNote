####**基本数据类型：**


| 数据类型 | 关键字 |字节数|默认值|范围|
|--------|--------|
|布尔|boolean|1|false|true,false|
|字节|byte|1|0|-128~127|
|短整|short|2|0|-2^15^~2^15^-1|
|整型|int|4|0|-2^31^~2^31^-1|
|长整|long|8|0|-2^63^~2^63^-1|
|字符|char|2|'\u0000'|0~2^16^-1|
|单精度浮点|float|4|0.0F|1.4013E-45~3.4028E+38|
|双精度浮点|double|8|0.0D|4.9E-324~1.7977E+308|

boolean类型只能是true,false;
```java
boolean isMarried = false;	//正确
boolean isMarried = 0;		//编译错误
boolean isFemale = null;	//编译错误

```

在JAVA中，如果数学表达式中都是整数，那么表达式的返回值只可能是int或long（而没有byte,short），所以：
```java
byte month = 1;
month = month + 2;		//编译错误
month = (byte)(monty+2);//正确，长范围赋值给短范围需强制转换
```

给整形数赋值时，如果在它的范围内，则可以直接赋值，否则必须强制类型转换：
```java
byte b = 13 ;		在其范围内(-128~127)
byte b = (byte)129;	不在其范围内，必须强转类型，最后值实际为-127；任何赋值强转后只取后8位
```

在一个整数后加上后缀L或l：1234L,1234l表示是一个长整形

#####**常用编码：**
**ASCII**:American Standard Code for Information Interchange,是为罗马字母编制的一套编码，主要用于表达现代英语和一些西欧语言。该编码实际上只有了一个字节的7位，一共表示128位字符。
**ISO-8859-1**:为西欧语言中的字符制定的编码，为一个字节来为字符编码，并与ASCII兼容。
**GB2312**：包含对简体中文字符的编码，一共7445个字符，其中6763个汉字和682个其它符号，并与ASCII兼容。
**GBK**：对GB2312字符编码的扩展，共21886个字符，分为汉字区和图形符号区，并与GB2312兼容。
**Unicode**：收录了世界所有的语言文字中的字符，UCS是指Universal Character Set是指采用Unicoce字符编码的通用字符集，Unicode有两种编码方案：
* 2个字节编码：被称作UCS-2。JAVA采用的就是这种编码；
* 4个字节编码：实际只用了31位，最高位为0，被称作UCS-4；

**UTF**：UCS Transformation Format,有些操作系统不支持16位或32位的Unicode字符编码，常见的的有UTF8,UTF7,UTF16.

UTF-8就是以1个字节为单元对UCS进行编码。UTF-8会根据UCS-2的表示的长度，采用不同的1，2，3个字节对UCS-2进行编码。

以后四种方法等价：
```java
char c = 'a';
char c = '\u0061';  //十六进制数据的Unicode字符编码
char c = 0x0061;	//十六进制数据的Unicode字符编码
char c = 97;		//十进制的Unicode字符编码
```

像单引号，双引号，反斜杠，回车，回首行,空格，TAB制表符，要使用转义字符：

| 单引号 | 双引号 |反斜杠|回车|回行首|空格|TAB制表符|三位八进制|十六进制
|--------|--------|
| \' | \" |\\\|\n|\r|\b|\t|\201|\u201或\x201

####**引用类型：**
分为：**类引用，接口引用，数组引用**

JAVA中，数组也被当作对象；

在如下：
`Doll beibei = new Doll("beibei")`
准确来说，beibei只是一个引用变量，是“Doll类引用类型”的变量，它引用指向用new语句创建的Doll对象，并且这个对象属于Doll类型。

beibei引用变量在哪个区？
* 如果是局部变量，则在JAVA栈区；（如在main()方法中定义，或者一个类中的方法块区中定义的变量，若所在方法没有被调用过，则该虚拟机的整个执行过程也不会加载它）
* 如果是某个类的静态变量，则位于方法区；（方法区是虚拟机第一次加载一个类时的地方）
* 如果是某个类的实例成员变量，侧位于堆区；（用new创建的实例对象的地方）

**new()语句的动作：**
a.为对象分配内在的空间，将对象的实例变量自动初始化为其变量类型的默认值。
b.如果类中的实例变量在声明时被显式初始化，那就初始化值赋给实例变量。
c.调用构造方法。
d.返回对象的引用。

如：
```java
public class Sample{
	int memberV1;
    int memberV2 = 1;
    int memberV3;
    public Sample(){memberV3 = 3;} //构造方法
    public static void main(String args[]){
    	Sample obj = new Sample();
    }
}
```
上面代码执行步骤：
a.为一个新的Sample对象分配内存空间，它所有的变量都被分配了内存空间，并自动初始化为其变量类型的默认值，其中3个变量都为0；
b.显式初始化memberV2变量，赋值为1；
c.调用构造方法，显式初始化变量memberV3，赋值为3;
d.返回这个类对象的引用；

####**变量作用域：**
**变量类型：**
成员变量：在类中声明，作用于整个类
局部变量：在一个方法中或代码声中的声明，代码块是指{}包起来的部分，如for（）{}这样。作用于这个方法，或者这个代码块
方法参数：作用于这个方法 
异常处理参数：catch(Exception e)语句中的异常参数e，作用域是紧跟着catch(Exception e)后面的{}代码块

注，成员变量可在类中方法外的任何地方定义，这看上去有点**先使用后定义的感觉**。而局部变量只能是**先定义再使用**；

**成员变量分为两种：**
* **静态**变量
* **实例**变量

用static修饰的成员变量，叫做静态变量，或类变量；别一种没有static修饰的叫做实例变量。
两者区别：
* 类的静态变量在内在中只有一个，Java虚拟机在加载类时为静态变量分配内存，静态变量位于方法区，可被类的所有实例共享。在类被卸载时，静态变量被销毁并撤销所占的内存。
* 类的每个实例都有相应的实例变量。每创建一个类的实例，JAVA虚拟机就会为之分配一个新的内存，并位于堆区中。实例变量的生命周期取决于实例的生命周期。

在编程时，尽可能地将局部变量的作用域最小化，**最好在要使用时才定义它**，而不要过早地定义它，这样当代码很冗长时可提高可读性。（这在C中是做不到滴，嘿嘿）

在方法中的参数传递过程中，如果传递的是基本数据类型，那方法将传递参数的值，所以修改这个值后，对原数没有影响；而传递的是引用类型时，修改它的值，也就修改了原来这个数的值了。

成员变量在未显示地初始化时，JAVA虚拟机会自动给它默认的初始化值。
局部变量在未显示地初始化时，JAVA虚拟机不会给它提供默认的初始化值，这一点要和成员变量区分开来，如果局部变量没有显示地初始化就开始使用，则会出现编译错误：
```java
public void method(){
	int a;
    a++;	//编译错误，局部变量没有显示地初始化
    System.out.println(a);
}
```

但如果一个局部变量没有显示地初始化，并且也没有使用过，那么编译和运行都能通过：
```java
public void method(){
	int x = 1;
    int y;
    int z =2;
}
```

####**直接数：**
```java
String name = "Tom";
int age = 15;
```
以上Tom和15就是直接数；

直接数共有7种类型：
int
long （一个数后面加一个l或L，就是long类型；若不加L时，给定的l在int范围内就是int型，超出int在long范围内就是long型，这还是挺智能滴）
float
double
char
String
boolean

由上可以看出基类型中除了byte和short类型都有直接数，引用类型中String也有直接数，

一个小数后面不加后缀f或d，那它默认是double类型，

JAVA中的**单引号，双引号**：
**单引号**：表示char类型，且只能包含一个字符
**双引号**：表示String类型，能包含0个到多个字符

char与String类型不能相互赋值：
```java
String s = 'a';		//编译错误
char c = "a";		//编译错误
```

把一个整数（通常是int）直接赋给byte,short,char类型时，如果在这三个表示的范围内，则可以直接赋值，否则需要强制转换。

boolean只接受false和true两个值；

整数可以直接把值赋给float或double类型变量；

关于赋值规律：取值范围小的数据类型允许直接赋值给取值范围大的数据类型。

















































